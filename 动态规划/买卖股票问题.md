https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/
# 1 买卖股票的最佳时机
**问题描述**：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**基本思路**：

这个问题中一共包含2种状态，分别是当前的天数和股票持有的状态，根据当前的状态来选择相应的动作，包括购买、卖出和保持不变。

$$ dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) $$
$$ dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) $$
$$ dp[0][0] = 0, dp[0][1] = -prices[0] $$

```python
def maxProfit(nums):
    dp = [[0, 0] for _ in range(len(nums))]
    dp[0][1] = -nums[0]
    for i in range(1, len(nums)):
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+nums[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-nums[i])
    return dp[-1][0]
```
# 2 买卖股票的最佳时机 III
**问题描述**：
**基本思路**：

# 3 打家劫舍
**问题描述**：

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**基本思路**：

$$ dp[i]=max(dp[i-1], dp[i-2]+nums[i]) $$
当前能偷到的最大金额只与前前两天的状态有关。若今天不能偷窃，则金额数依然等于前一天的金额；若今天可以偷窃，则金额数为前天的金额加上今天偷的金额。

第二种思路与股票问题类似。该问题包含两种状态，一种是当前天数，一种是是否偷窃。dp[i][0]表示今天不偷窃，dp[i][1]表示今天偷窃。

$$ dp[i][0] = max(dp[i-1][0], dp[i-1][1]) $$
$$ dp[i][1] = dp[i-1][0] + nums[i] $$
$$ dp[0][0] = 0 $$
$$ dp[0][1] = nums[0] $$

```python
def maxProfit(nums):
    dp = [[0,0] for _ in range(len(nums))]
    dp[0][1] = nums[0]
    for i in range(1, len(nums)):
        dp[i][0] = max(dp[i-1][0], dp[i-1][1])
        dp[i][1] = dp[i-1][0] + nums[i]
    return max(dp[-1][0], dp[-1][1])
```
# 4 打家劫舍 II
**问题描述**：

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。**这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的**。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**基本思路**：

在I的基础上加入约束：第一个房间和最后一个房间不能同时被偷窃。因此，去掉头或尾就可以变成问题1，可以直接分两种情况，若第一个房间被偷，则返回dp[-1][0]；若第一个房间没有被偷，则返回max(dp[-1][0], dp[-1][1])。最后，取两者的最大值即可。
```python
def maxProfit(nums):
    dp = [[0,0] for _ in range(len(nums)-1)]
    # 被偷
    dp[0][1] = nums[0]
    for i in range(1, len(nums)-1):
        dp[i][0] = max(dp[i-1][0], dp[i-1][1])
        dp[i][1] = dp[i-1][0] + nums[i]
    profit1 = max(dp[-1][0], dp[-1][1])
    # 不偷
    dp[0][0] = 0
    dp[0][1] = nums[1]
    for i in range(2, len(nums)):
        dp[i-1][0] = max(dp[i-2][0], dp[i-2][1])
        dp[i-1][1] = dp[i-2][0] + nums[i]
    profit2 = max(dp[-1][0], dp[-1][1])
    return max(profit1, profit2)
```